name: Deploy to AWS

on:
  push:
    branches:
      - main

env:
  AWS_REGION: us-east-1 # Região da AWS, alinhada com o Terraform
  
  
  IMAGE_TAG: ${{ github.sha }}
  DOTNET_VERSION: '9.0.x' # Versão do .NET

jobs:
  build-and-test:
    name: Build and Test .NET
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Restore dependencies
      run: dotnet restore

    - name: Build
      run: dotnet build --no-restore

    - name: Test
      run: dotnet test --no-build --verbosity normal

  

  terraform-apply:
    name: Apply Terraform Infrastructure
    runs-on: ubuntu-latest
    needs: build-and-test
    outputs:
      ec2_public_ip: ${{ steps.terraform-apply-step.outputs.ec2_public_ip }}

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.6.0 # Fixando a versão do Terraform para uma estável

    - name: Terraform Init
      run: terraform init
      working-directory: terraform

    - name: Terraform Validate
      run: terraform validate
      working-directory: terraform    

    - name: Terraform Plan
      run: terraform plan -out=tfplan
      working-directory: terraform

    - name: Terraform Apply
      id: terraform-apply-step # Adicionando um ID para referenciar as saídas
      run: terraform apply -auto-approve tfplan
      working-directory: terraform
      # Capturando a saída do IP público
      env:
        TF_VAR_ec2_public_ip: ${{ steps.terraform-apply-step.outputs.ec2_public_ip }}

  deploy-to-ec2:
    name: Deploy Application to EC2
    runs-on: ubuntu-latest
    needs: terraform-apply

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.7.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: Get EC2 Public IP
      id: get-ip
      run: echo "EC2_PUBLIC_IP=${{ needs.terraform-apply.outputs.ec2_public_ip }}" >> $GITHUB_ENV

    - name: Deploy to EC2
      env:
        DOCKER_IMAGE: your-docker-image-name:tag # Substitua pelo nome da sua imagem Docker
      run: |
        # Wait for SSH to be available
        for i in $(seq 1 10);
        do
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ubuntu@${{ env.EC2_PUBLIC_IP }} "echo 'SSH is up!'" && break
          sleep 10
        done

        # Pull Docker image
        ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ubuntu@${{ env.EC2_PUBLIC_IP }}
          "docker pull ${DOCKER_IMAGE}"

        # Stop and remove old container if exists
        ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ubuntu@${{ env.EC2_PUBLIC_IP }}
          "docker stop quiosque-food-app || true && docker rm quiosque-food-app || true"

        # Run new container
        ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ubuntu@${{ env.EC2_PUBLIC_IP }}
          "docker run -d --name quiosque-food-app -p 80:8080 ${DOCKER_IMAGE}"

  